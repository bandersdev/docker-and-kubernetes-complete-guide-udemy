Building Custom Images Through Docker Server

Creating Docker  Images

- Dockerfile -> Docker Client -> Docker Server -> Usable Image
- The Docker server does the heavy lifting
- Dockerfiles are plain text files that contain instructions to run commands, copy files, etc
- Creating a Dockerfile
	- Specify a base image
	- Run some additional commands to install additional programs
	- Specify a command to run on container startup

Building a Dockerfile

- Going to make a Dockerfile that runs redis-server
- see source_material/3-building-custom-images/redis-image/Dockerfile
- Build the Dockerfile in the current directory with docker build .

Dockerfile Teardown

- Deep dive on the Dockerfile from the previous step
- Each line starts with an instruction followed by arguments
	- ex. 'FROM alpine' to base our image on the alpine image
	- ex. 'RUN apk add --update redis' to add the updated redis package
	- ex. 'CMD ["redis-server"]' to run the redis server on startup

What's a Base Image?

- Analogy: Writing a Dockerfile is like being given a computer with no OS and being told to install Chrome
- Flow:
	- Install an operating system
	- Start up your default browser
	- Navigate to chrome.google.com
	- Download Installer
	- Open file/folder explorder
	- Execute chrome installer
	- Execute chrome
- All followon steps depend on installing the operating system
- When specifying the base image with FROM that is installing the base operating system
- We use operating systems that come with programs installed that are useful
- Alpine is a very small linux image, and its good to use as a base
	- apk package manager is useful for installing other software

The Build Process in Detail

- Running docker build passes the dockerfile
- After docker build the directory specified is called the build context
- For every operation line in the dockerfile there is a step during the build process
- First, docker checks if the source image exists, and downloads it if not
- In the run step it says "Running in <container id>" and later it says "Removing intermediate container <same container id>"
	- This is repeated for later steps
	- There is not a step like this for getting the image
- When the RUN step starts it looks back at the FROM step and the image that came out of it (alpine)
	- Then it creates a brand new alpine container with the RUN command as its primary running process
	- The container is then stopped, a file system snapshot is saved as a temporary image and that image is used as the base for the next step. The container is then deleted
- For the CMD step take the image from the previous step and create a new temporary container from it
	- Then the container is shut down and a snapshot is taken and saved as the final image used to launch a redis container
- With each step creating a container and image its best to limit the number of run commands and to generally consolidate commands where possible

A Brief Recap

- Refreshes the above section
- In the RUN section:
	- Get image from previous step
	- Create container out of it
	- Run 'apk add --update redis' in container
	- Take snapshot of tempory container
	- Shut down and remove the temporary container
	- Get image ready for the next instruction
- Same thing for CMD except replace the run step with telling the container what to run when started
- The final image is the one generated by the last step of the docker process

Rebuilding with Cache

- Test adding gcc with apk
- Takes one extra step to create the image
- Rebuild the image
	- On rebuild we don't have to reload the image
	- On step two (the first RUN) we see that it uses the cache
		- If nothing changes from the previous run it uses a cache
- If we rebuild again each step is cached
- So, when a change happens to a dockerfile we re-run all steps starting with that change
- If the steps are the same, but reorderd the cache will not be used cause the order of operations and intermediate images will change

Tagging an Image

- Its nice to be able to refer to things like alpine, or redis-server instead of having to work with container ids
- During the build the -t flag is used to set the name
	- Format is <docker id>/<project name>:<version>
		- Version is frequently latest, but a number otherwise
		- Community images like hello-world of busybox do not apply the docker id convention
- Technically, the tag is just the version. The rest is the repository/project name, but the whole thing is called tagging

Manual Image Generation with Docker Commit

- This isn't something that is likely to be used regularly or ever
- From before we know we can create a container from an image, but that also goes the other way. Containers can create images
- From the command line you can run steps to do what would normally happen in a Dockerfile
- Start alpine with an attached termial
	- docker run -it alpine sh
	- apk add --update redis
- Now take that running container, assign a command to it, and save it as an imate
	- Get the container id
	- Run docker commit to create a new container:
		- docker commit -c 'CMD ["redis-server"]' 1d335a7f152b
		- docker run <new container id>
- With container ids you can copy the first section of it and Docker will assume that is unique enough and go with it.